#!/usr/bin/php -q
<?php

/**
 * Generate a raw database class for each table. Instead of doing it on the fly each time, I run
 * this after any database changes and store it in lib/class.DB.php.  Then, for each of the classes,
 * I'll make an exetended class based on the DB_{object} class.
 * I know, I'll get hate for not doing this on-the-fly/dynamically, but I've done it many different
 * ways, many times, and I always tend to come back to this method. It's more stable, predictable, 
 * efficient, and is nearly always fastest.
 * This outputs text directly to stdout.
 *
 * NOTE!!! If you use non-standard field names in your database, this won't like it. Don't use spaces,
 * ticks, utf-8 odd chars in your table/field names, or you're gonna have a bad time. Why do that to yourself?
 *
 * Also note, there is no DELETE. I tend to HATE to delete things from a DB (there's always analytics to get).
 * Instead I use an "Active" field - if it's 0, then it's "deleted".
 *
 * This is run from the command line, so set_include_path may need to be updated.
 *
 * Run with:   ./gen_db_classes.php > ../lib/class.db_classes.php
 *
 * @author Steve Cook <booyahmedia@gmail.com>
 * @copyright 1998 - 2013 Stephen Cook
 * @license http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * @link http://booyahmedia.com/
 * @version Release: @package_version@
 * @todo Add more features to take advantage of PDO.
 *
 **/

set_include_path(".:../lib");

require_once("globals.php");
require_once("class.db.php");

CreateDBClass(DB_NAME);


/**
 * Starting function to start the output and echo required includes. Then calls function to build each object.
 * @param string $db_name The name of the database.
 **/
function CreateDBClass($db_name) {
	$db=db::factory();

	print("<"."?php\n");
	print("\n/*\n ****************************************************************\n");
	print(" * *****   DO NOT EDIT THIS FILE!!!! ******************************\n");
	print(" * ***  This file is generated automatically to create a DATABASE class ONLY.\n");
	print(" * *** Generated on: ".date("r")."\n");
	print(" *****************************************************************\n");
	print(" */\n");
	print("\nrequire_once('globals.php');"); // defines the db details.
	print("\nrequire_once('class.db.php');"); // defines the db details.
	$tables=$db->getArray("SHOW TABLES");
	foreach($tables as $table) {
		ListFields($table[0]);
	}
	print("\n?".">");

}


/**
 * Function to create each table object.
 * @param string $table The name of the table.
 **/
function ListFields($table) {
	$db=db::factory();

	// Start the class - called DB_{table name}
	print("\n\n\nclass DB_$table {\n");

	$fields=$db->getArray("SHOW COLUMNS FROM $table"); // Field and Type are the column names
	$fa=array(); // I used to use $fa in more places, but optimized to not use it as much
	$x=0;
	foreach($fields as $field) {
		echo "\tpublic \$".$field['Field'].";  \t// ".$field['Type']."\n";
		$fa[$x++]=$field['Field'];
	}


	// output the constructor, which either loads the object if an ID is included or sets defaults.
	print("\n\tpublic function __construct(\$id=0) {\n");
	print("\t\t\$db=db::factory();\n");
	echo "\t\tif(\$id>0){\n"; // This is for the case of loading an ID
	print("\t\t\t\$q=\"select * from ".DB_NAME.".$table where ".$fa[0]."='\$id' LIMIT 1\";\n");
	print("\t\t\t\$row=\$db->getRow(\$q);\n");
	print("\t\t\tif(count(\$row)<1) return(0);\n");
	print("\t\t\tforeach(\$row as \$k=>\$v) \$this->{\$k}=\$v;\n");
	print("\t\t\treturn(1);\n");
	echo "\t\t} else {\n";

	// Cycle through and create a public variable for each field. THere may be other field Types to check
	foreach($fields as $field) {
		print("\t\t\t\$this->".$field['Field']."=");
		if(strpos($field['Type'],"int(")!==false) {
			print("0;\n");
		} else if( strpos($field['Type'],"float")!==false 
			|| strpos($field['Type'],"double")!==false
			|| strpos($field['Type'],"deci")!==false) {
			print("0.00;\n");
		} else {
			print("'';\n");
		}
	}	

	print("\t\t}\n");
	print("\t}\n\n");

	// Create the load function - this reads from the DB and puts into the instantiated object.
	print("\tpublic function load(\$id=0) {\n");
	print("\t\t\$db=db::factory();\n");;
	print("\t\t\$q=\"SELECT * FROM ".DB_NAME.".$table WHERE ${table}ID='\$id' LIMIT 1\";\n");
	print("\t\t\$row=\$db->getRow(\$q);\n");
	print("\t\tif(count(\$row)<1) return(0);\n");
	print("\t\tforeach(\$row as \$k=>\$v) \$this->{\$k}=\$v;\n");
	print("\t\treturn(true);\n");
	print("\t}\n\n");

	//Generate the Field list and the value list - note: no checks are done! This is done all at once to be faster
	//but speed doesn't really matter as this is only run once.
	foreach($fields as $i=>$field) {
		if($i==0) {
			$part2="INSERT INTO ".DB_NAME.".$table (".$field['Field'];
			$part3="\$this->".$field['Field'];
			$part4="UPDATE ".DB_NAME.".$table SET ".$field['Field']."='\$this->".$field['Field']."'";
		} else {
			$part2.=",".$field['Field'];
			$part3.=",'\$this->".$field['Field']."'";
			$part4.=",".$field['Field']."='\$this->".$field['Field']."'";
		}


	}

	$q_insert="$part2) VALUES ($part3)";
	$q_update="$part4 WHERE $fa[0]=\$id LIMIT 1";

	// output the save method
	$f_savetable=<<<__SAVE_TABLE__
        public function save(\$id=0) {
	\$db=db::factory();
	if(\$id==0) {
	        \$q="$q_insert";
	        \$save_type="New Save";
	} else {
	        \$q="$q_update";
	        \$save_type="Update";
	}
	if(\$id==0) {
	        \$result=\$db->execute(\$q);
		\$id=(\$result==true)?\$db->getLastId():0;
	} else {
	        \$result=\$db->execute(\$q);
	}
	if(!\$result) {
	        //print("\$save_type FAILED.");
	        return(0);
	}
	return(\$id);
        }
__SAVE_TABLE__;
	echo $f_savetable;

	// Set a local variable to the DB_NAME constant to use below 
	$db_name=DB_NAME;

	// Output the update method
	$f_updates=<<<__UPDATE_TABLE__

        public function updateFields(\$aUpdates) {
	\$db=db::factory();
	\$COMMA="";
	\$q="UPDATE $db_name.$table SET ";
	foreach(\$aUpdates as \$k=>\$v) {
	        \$q.="\$COMMA\$k='\$v'";
	        \$COMMA=",";
	        \$this->\$k=\$v;
	}
	\$q.=" WHERE $fa[0]=\$this->$fa[0] LIMIT 1";

	\$result=\$db->execute(\$q);
	if(!\$result) {
	        //print("\$save_type FAILED.");
	        return(false);
	} else {
	        return(true);
	}
        }


__UPDATE_TABLE__;
        echo "\n\t".$f_updates;
	print("\n} #End of class $table");

}
